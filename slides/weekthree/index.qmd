---
title: "Object-Oriented Programming in Python"
description: "What are the key features of object-oriented programming in Python?"
date: "2025-09-08"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Prosegrammers"
---

# What are the main goals of object-oriented programming?

::: incremental

- Write code that reflects thought and the world
- Enable code reuse and sharing among programmers
- Encourage the creation of well-designed software
- Ensure that software is easy to maintain and extend

:::

## What is a class? What is an object?

::: incremental

- A class is a **blueprint** for creating objects
- An object is an **instantiation** of a class
- A class defines the **attributes** and **methods** of an object
    - **Attributes** are the data that an object holds
    - **Methods** are the behaviors that an object can perform

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.9em;"}

{{< iconify fa6-solid microscope >}} Brainstorm an example of a class and an
object that might exist in a program you use! After identifying the attributes
and the methods, reflect on the benefits of object-oriented design.

:::

## Type Inference in Python

```{python}
mylist = []
print(type(mylist))
print(isinstance(mylist, list))
print(isinstance(mylist, str))
```

::: {.fragment .fade style="margin-top: 0.0em; font-size: 0.9em;"}

- Key insights about this source code:
    - `mylist = []` creates an empty list
    - `type(mylist)` returns the type of the list
    - `isinstance` returns `True` or `False` for provided type
    - `isinstance(mylist, list)` checks if `mylist` is a list
    - Same approach works for other data types!

:::

## Existing types available in Python

```{python}
def example_function():
  return 0
print(type(example_function))
```

<p class="codespacer">

```{python}
def generator_example(n):
  for i in range(n):
    yield i
print(type(generator_example))
print(type(generator_example(5)))
```

::: {.fragment .fade style="margin-top: 0.25em; font-size: 0.9em;"}

- `type` shows that functions and generators have their own types
- What are the similarities and differences for these two types?
- How do `return` and `yield` influence a function's behavior?

:::

## Explore use of the `type` function

```{pyodide}
#| autorun: true
#| max-lines: 10
# define variables of different types
integer_var = 10
float_var = 10.5
string_var = "Hello, World!"
list_var = [1, 2, 3, 4, 5]
dict_var = {"key1": "value1", "key2": "value2"}

# display the type of each variable
print("Type of integer_var:", type(integer_var))
print("Type of float_var:", type(float_var))
print("Type of string_var:", type(string_var))
print("Type of list_var:", type(list_var))
print("Type of dict_var:", type(dict_var))
```

::: {.fragment style="margin-top: 0.15em; font-size: 0.80em;"}

- {{< iconify fa6-solid microscope >}} **Key Task**: Add other types, including
  those that contain different types!

:::

## What if we don't create objects?

```{python}
u = (3,4)
v = (3,6)
def add(a, b):
  return (a[0] + b[0], a[1] + b[1])
def subtract(a,b):
  return (a[0] - b[0], a[1] - b[1])
def dot(a, b):
  return (a[0] * b[0] + a[1] * b[1])
def norm(a):
  return (a[0] * a[0] + a[1] * a[1]) ** 0.5
def isvertical(a):
  return a[0] == 0
print(norm(u))
print(add(u,v))
print(u + v)
print(isvertical(subtract(v, u)))
```

## Explore `tuple` for encoding state

```{pyodide}
#| autorun: true
#| max-lines: 10
u = (3,4)
v = (3,6)
def add(a, b):
  return (a[0] + b[0], a[1] + b[1])
def subtract(a,b):
  return (a[0] - b[0], a[1] - b[1])
def dot(a, b):
  return (a[0] * b[0] + a[1] * b[1])
def norm(a):
  return (a[0] * a[0] + a[1] * a[1]) ** 0.5
def isvertical(a):
  return a[0] == 0
print(norm(u))
print(add(u,v))
print(u + v)
print(isvertical(subtract(v, u)))
```

::: {.fragment style="margin-top: 0.2em; font-size: 0.80em;"}

- {{< iconify fa6-solid lightbulb >}} **Key Questions**: What are the strengths
    and weaknesses of this approach to representing vectors? How could this
    approach lead to program defects?

:::

## An object-oriented alternative

::: {.fragment .fade-right style="margin-top: 0.5em; font-size: 0.9em;"}

```{python}
class Vector:
  def __init__(self, x, y):
    try:
      self.x = float(x)
      self.y = float(y)
    except ValueError:
      self.x = 0.0
      self.y = 0.0
  def norm(self):
    return (self.x ** 2 + self.y ** 2) ** 0.5
  def __add__(self, other):
    newx = self.x + other.x
    newy = self.y + other.y
    return Vector(newx, newy)
  def __str__(self):
    return "({:.2f}, {:.2f})".format(self.x, self.y)
u = Vector(3,4)
v = Vector(3,6)
print(u + v)
```

:::

## Explore an object-oriented approach

```{pyodide}
#| autorun: true
#| max-lines: 12
class Vector:
  def __init__(self, x, y):
    try:
      self.x = float(x)
      self.y = float(y)
    except ValueError:
      self.x = 0.0
      self.y = 0.0
  def norm(self):
    return (self.x ** 2 + self.y ** 2) ** 0.5
  def __add__(self, other):
    newx = self.x + other.x
    newy = self.y + other.y
    return Vector(newx, newy)
  def __str__(self):
    return "({:.2f}, {:.2f})".format(self.x, self.y)
u = Vector(3,4)
v = Vector(3,6)
print(u + v)
```

::: {.fragment style="margin-top: 0.2em; font-size: 0.80em;"}

- {{< iconify fa6-solid lightbulb >}} **Key Questions**: After trying different
instances of `Vector`, what is the state and behavior? What are the strengths
and weaknesses of this approach to representing vectors? How could this approach
lead to program defects?

:::

# What are the principles of object-oriented programming?

::: incremental

- **Abstraction**: Hide implementation details
- **Inheritance**: Create new classes from existing classes
- **Encapsulation**: Group related data and methods together
- **Polymorphism**: Allow objects to take on multiple forms

:::

## Encapsulation with `Triangle`

```{python}
class Triangle:
    def __init__(self, points):
        self._sides = 3
        self._points = list(points)
        if len(self._points) != 3:
            raise ValueError("Wrong number of points.")

    def sides(self):
        return 3

    def __str__(self):
        return "I’m a triangle."
```

::: {.fragment .fade-right style="margin-top: 0.5em; font-size: 0.9em;"}

- What state does a `Triangle` object have?
- How can we access the state of a `Triangle` object?
- What are the benefits and limitations of encapsulation?

:::

## Encapsulation with `Square`

```{python}
class Square:
    def __init__(self, points):
        self._sides = 4
        self._points = list(points)
        if len(self._points) != 4:
            raise ValueError("Wrong number of points.")

    def sides(self):
        return 4

    def __str__(self):
        return "I’m so square."
```

::: {.fragment .fade-right style="margin-top: 0.5em; font-size: 0.9em;"}

- What state does a `Square` object have?
- How can we access the state of a `Square` object?
- Wait, what is the purpose of `__init__` and `__str__`?

:::

## Wait, what is the relationship between a `Square` and a `Triangle`?

```{python}
class Polygon:
    def __init__(self, sides, points):
        self._sides = sides
        self._points = list(points)
        if len(self._points) != self._sides:
            raise ValueError("Wrong number of points.")

    def sides(self):
        return self._sides
```

::: {.fragment .fade-right style="margin-top: 0.5em; font-size: 0.9em;"}

- The `Polygon` class is a *superclass* of `Triangle` and `Square`
- The `Triangle` and `Square` classes are *subclasses* of `Polygon`
- The `Polygon` class is a *generalization* of `Triangle` and `Square`

:::

## Connecting `Triangle` and `Square` to the `Polygon` Superclass


```{python}
class Triangle(Polygon):
    def __init__(self, points):
        Polygon.__init__(self, 3, points)

    def __str__(self):
        return "I’m a triangle."

class Square(Polygon):
    def __init__(self, points):
        Polygon.__init__(self, 4, points)

    def __str__(self):
        return "I’m so square."
```

::: {.fragment .fade-up style="margin-top: 0.5em; font-size: 0.8em;"}

- Forms an "is-a" relationship between:
  - `Triangle` and `Polygon` and also `Square` and `Polygon`

:::

## What is duck typing? How does it work in the Python language?

::: {.incremental style="font-size: 1.025em;"}

- Python is a dynamically typed language

- Python uses duck typing to determine types

- Remember the silly adage of "If it walks like a duck and quacks like a duck,
  then it must be a duck"

- Inheritance is not only way to create an "is-a"
  relationship!

- Yet, inheritance makes the "is-a" relationship explicit

- {{< iconify fa6-solid gear >}} **Let's explore an example of duck typing in Python!**

:::

## Connecting `Triangle` and `Square` to the `Polygon` Superclass

```{python}
class PolygonCollection:
    def __init__(self):
        self._triangles = []
        self._squares = []

    def add(self, polygon):
        if polygon.sides() == 3:
            self._triangles.append(polygon)
        if polygon.sides() == 4:
            self._squares.append(polygon)
```

::: {.fragment .fade-up style="margin-top: 0.5em; font-size: 0.85em;"}

- The `polygon` parameter can be any object with a `sides` method
- This is an example of parametric polymorphism in Python
- Again, inheritance is not the only way to create an "is-a" relationship!

:::

## Using composition in Python

```{python}
class MyLimitedList:
    def __init__(self):
        self._L = []

    def append(self, item):
        self._L.append(item)

    def __getitem__(self, index):
        return self._L[index]
```

## Object-oriented programming for prosegrammers

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **OOP enables powerful document engineering tools**
  - Create reusable document processing classes
  - Build extensible document analysis frameworks
  - Design flexible document generation systems

- {{< iconify fa6-solid book-open >}} **Document classes represent real-world entities**
  - `Document` class for text content and metadata
  - `Report` class for structured business documents
  - `Manual` class for instructional content
  - `Analyzer` class for text processing operations

- {{< iconify fa6-solid lightbulb >}} **Inheritance creates document type hierarchies**
  - Base `Document` class with common functionality
  - Specialized subclasses for different document types
  - Shared methods and properties through inheritance

:::

## Creating a document class

```{python}
from typing import Dict, List, Optional
from datetime import datetime

class Document:
    """A base class representing a document in our document engineering system."""
    
    def __init__(self, title: str, author: str, content: str = ""):
        """Initialize a document with basic properties."""
        self.title = title
        self.author = author
        self.content = content
        self.created_date = datetime.now()
        self.word_count = len(content.split()) if content else 0
        self.metadata: Dict[str, str] = {}
    
    def add_metadata(self, key: str, value: str) -> None:
        """Add metadata to the document."""
        self.metadata[key] = value
    
    def get_summary(self) -> str:
        """Generate a summary of the document."""
        return f"'{self.title}' by {self.author} ({self.word_count} words)"
    
    def __str__(self) -> str:
        """String representation of the document."""
        return self.get_summary()
```

::: {.fragment .fade style="margin-top: -0.1em; font-size: 0.85em;"}

- **Document class encapsulates document state and behavior**
- **Methods provide document operations**: metadata management, summaries
- **Foundation for building document engineering tools**

:::

## Exploring the Document class

```{pyodide}
#| autorun: true
#| max-lines: 12
from typing import Dict
from datetime import datetime

class Document:
    def __init__(self, title: str, author: str, content: str = ""):
        self.title = title
        self.author = author
        self.content = content
        self.created_date = datetime.now()
        self.word_count = len(content.split()) if content else 0
        self.metadata: Dict[str, str] = {}
    
    def add_metadata(self, key: str, value: str) -> None:
        self.metadata[key] = value
    
    def get_summary(self) -> str:
        return f"'{self.title}' by {self.author} ({self.word_count} words)"
    
    def __str__(self) -> str:
        return self.get_summary()

# Create a sample document
doc = Document("Python Guide", "Jane Smith", "This is a guide about Python programming.")
doc.add_metadata("language", "English")
doc.add_metadata("version", "1.0")
print("Document:", doc)
print("Metadata:", doc.metadata)
```

::: {.fragment style="margin-top: -0.1em; font-size: 0.8em;"}

- {{< iconify fa6-solid lightbulb >}} **Key insights**: Objects encapsulate both data and operations
- **Metadata system**: Flexible key-value storage for document properties
- **Automatic calculations**: Word count computed from content

:::

## Inheritance: Specialized document types

```{python}
class TechnicalDocument(Document):
    """A specialized document for technical content."""
    
    def __init__(self, title: str, author: str, content: str = "", 
                 technical_level: str = "beginner"):
        """Initialize a technical document with additional properties."""
        super().__init__(title, author, content)
        self.technical_level = technical_level
        self.code_examples: List[str] = []
    
    def add_code_example(self, code: str) -> None:
        """Add a code example to the technical document."""
        self.code_examples.append(code)
        self.word_count = len(self.content.split())  # Recalculate word count
    
    def get_complexity_score(self) -> float:
        """Calculate document complexity based on technical level and code."""
        base_score = {"beginner": 1.0, "intermediate": 2.0, "advanced": 3.0}
        code_multiplier = 1 + (len(self.code_examples) * 0.1)
        return base_score.get(self.technical_level, 1.0) * code_multiplier
    
    def get_summary(self) -> str:
        """Enhanced summary for technical documents."""
        base_summary = super().get_summary()
        return f"{base_summary} - Level: {self.technical_level} ({len(self.code_examples)} examples)"
```

::: {.fragment .fade style="margin-top: -0.1em; font-size: 0.85em;"}

- **Inheritance extends base functionality**: `TechnicalDocument` inherits from `Document`
- **Specialized behavior**: Code examples, complexity scoring, enhanced summaries
- **Polymorphism**: `get_summary()` method overridden for technical context

:::

## Using inheritance with document types

```{pyodide}
#| autorun: true
#| max-lines: 15
from typing import Dict, List
from datetime import datetime

class Document:
    def __init__(self, title: str, author: str, content: str = ""):
        self.title = title
        self.author = author
        self.content = content
        self.created_date = datetime.now()
        self.word_count = len(content.split()) if content else 0
        self.metadata: Dict[str, str] = {}
    
    def add_metadata(self, key: str, value: str) -> None:
        self.metadata[key] = value
    
    def get_summary(self) -> str:
        return f"'{self.title}' by {self.author} ({self.word_count} words)"

class TechnicalDocument(Document):
    def __init__(self, title: str, author: str, content: str = "", 
                 technical_level: str = "beginner"):
        super().__init__(title, author, content)
        self.technical_level = technical_level
        self.code_examples: List[str] = []
    
    def add_code_example(self, code: str) -> None:
        self.code_examples.append(code)
    
    def get_complexity_score(self) -> float:
        base_score = {"beginner": 1.0, "intermediate": 2.0, "advanced": 3.0}
        code_multiplier = 1 + (len(self.code_examples) * 0.1)
        return base_score.get(self.technical_level, 1.0) * code_multiplier
    
    def get_summary(self) -> str:
        base_summary = super().get_summary()
        return f"{base_summary} - Level: {self.technical_level} ({len(self.code_examples)} examples)"

# Create different document types
basic_doc = Document("Simple Guide", "John Doe", "Basic content here.")
tech_doc = TechnicalDocument("Advanced Python", "Jane Smith", "Complex Python concepts.", "advanced")
tech_doc.add_code_example("def fibonacci(n): return n if n <= 1 else fibonacci(n-1) + fibonacci(n-2)")
tech_doc.add_metadata("language", "Python")

print("Basic document:", basic_doc)
print("Technical document:", tech_doc)
print("Complexity score:", tech_doc.get_complexity_score())
```

::: {.fragment style="margin-top: -0.1em; font-size: 0.8em;"}

- {{< iconify fa6-solid lightbulb >}} **Inheritance benefits**: Code reuse, specialization, polymorphism
- **Different document types**: Each with appropriate behavior and properties
- **Complexity analysis**: Technical documents can be analyzed for difficulty

:::

## Polymorphism: Document processors

```{python}
from abc import ABC, abstractmethod
from typing import List

class DocumentProcessor(ABC):
    """Abstract base class for document processing operations."""
    
    @abstractmethod
    def process(self, document: Document) -> str:
        """Process a document and return results."""
        pass
    
    @abstractmethod
    def get_processor_type(self) -> str:
        """Return the type of processing this processor performs."""
        pass

class WordCountProcessor(DocumentProcessor):
    """Processor that counts words in documents."""
    
    def process(self, document: Document) -> str:
        """Count words and return statistics."""
        words = document.content.split()
        return f"Word count: {len(words)}"
    
    def get_processor_type(self) -> str:
        return "word_counter"

class KeywordExtractor(DocumentProcessor):
    """Processor that extracts keywords from documents."""
    
    def __init__(self, keywords: List[str]):
        """Initialize with keywords to search for."""
        self.keywords = [kw.lower() for kw in keywords]
    
    def process(self, document: Document) -> str:
        """Extract and count keyword occurrences."""
        content_lower = document.content.lower()
        found_keywords = []
        for keyword in self.keywords:
            if keyword in content_lower:
                count = content_lower.count(keyword)
                found_keywords.append(f"{keyword}: {count}")
        return "Keywords found: " + ", ".join(found_keywords) if found_keywords else "No keywords found"
    
    def get_processor_type(self) -> str:
        return "keyword_extractor"
```

::: {.fragment .fade style="margin-top: -0.1em; font-size: 0.85em;"}

- **Abstract base class**: Defines interface for document processors
- **Polymorphism**: Different processors implement the same interface
- **Extensibility**: New processors can be added without changing existing code

:::

## Polymorphism in action

```{pyodide}
#| autorun: true
#| max-lines: 20
from abc import ABC, abstractmethod
from typing import List, Dict
from datetime import datetime

class Document:
    def __init__(self, title: str, author: str, content: str = ""):
        self.title = title
        self.author = author
        self.content = content
        self.created_date = datetime.now()
        self.word_count = len(content.split()) if content else 0
        self.metadata: Dict[str, str] = {}

class DocumentProcessor(ABC):
    @abstractmethod
    def process(self, document: Document) -> str:
        pass
    
    @abstractmethod
    def get_processor_type(self) -> str:
        pass

class WordCountProcessor(DocumentProcessor):
    def process(self, document: Document) -> str:
        words = document.content.split()
        return f"Word count: {len(words)}"
    
    def get_processor_type(self) -> str:
        return "word_counter"

class KeywordExtractor(DocumentProcessor):
    def __init__(self, keywords: List[str]):
        self.keywords = [kw.lower() for kw in keywords]
    
    def process(self, document: Document) -> str:
        content_lower = document.content.lower()
        found_keywords = []
        for keyword in self.keywords:
            if keyword in content_lower:
                count = content_lower.count(keyword)
                found_keywords.append(f"{keyword}: {count}")
        return "Keywords found: " + ", ".join(found_keywords) if found_keywords else "No keywords found"
    
    def get_processor_type(self) -> str:
        return "keyword_extractor"

# Create documents and processors
doc1 = Document("Python Tutorial", "Alice", "Python is a programming language used for data analysis and web development.")
doc2 = Document("Data Science Guide", "Bob", "Data science involves statistics, machine learning, and programming.")

processors = [WordCountProcessor(), KeywordExtractor(["python", "data", "programming"])]

for doc in [doc1, doc2]:
    print(f"Processing: {doc.title}")
    for processor in processors:
        result = processor.process(doc)
        print(f"  {processor.get_processor_type()}: {result}")
    print()
```

::: {.fragment style="margin-top: -0.1em; font-size: 0.8em;"}

- {{< iconify fa6-solid lightbulb >}} **Polymorphic processing**: Same interface, different behaviors
- **Flexible analysis**: Documents can be processed by any compatible processor
- **Extensible system**: New processors work with existing documents

:::

## Composition: Document generators

```{python}
from typing import List, Dict, Optional

class DocumentSection:
    """Represents a section within a document."""
    
    def __init__(self, title: str, content: str):
        """Initialize a document section."""
        self.title = title
        self.content = content
        self.word_count = len(content.split())
    
    def __str__(self) -> str:
        """String representation of the section."""
        return f"## {self.title}\n\n{self.content}"

class DocumentGenerator:
    """A document generator that composes documents from sections."""
    
    def __init__(self, title: str, author: str):
        """Initialize the document generator."""
        self.title = title
        self.author = author
        self.sections: List[DocumentSection] = []
        self.metadata: Dict[str, str] = {}
    
    def add_section(self, section: DocumentSection) -> None:
        """Add a section to the document."""
        self.sections.append(section)
    
    def add_metadata(self, key: str, value: str) -> None:
        """Add metadata to the document."""
        self.metadata[key] = value
    
    def generate_markdown(self) -> str:
        """Generate the complete document in Markdown format."""
        header = f"# {self.title}\n\n**Author:** {self.author}\n\n"
        if self.metadata:
            header += "**Metadata:**\n"
            for key, value in self.metadata.items():
                header += f"- {key}: {value}\n"
            header += "\n"
        
        body = "\n\n".join(str(section) for section in self.sections)
        return header + body
    
    def get_total_word_count(self) -> int:
        """Calculate total word count across all sections."""
        return sum(section.word_count for section in self.sections)
```

::: {.fragment .fade style="margin-top: -0.1em; font-size: 0.85em;"}

- **Composition over inheritance**: Document generator *has* sections
- **Flexible structure**: Sections can be added dynamically
- **Clean separation**: Each class has a single responsibility

:::

## Building documents with composition

```{pyodide}
#| autorun: true
#| max-lines: 20
from typing import List, Dict

class DocumentSection:
    def __init__(self, title: str, content: str):
        self.title = title
        self.content = content
        self.word_count = len(content.split())
    
    def __str__(self) -> str:
        return f"## {self.title}\n\n{self.content}"

class DocumentGenerator:
    def __init__(self, title: str, author: str):
        self.title = title
        self.author = author
        self.sections: List[DocumentSection] = []
        self.metadata: Dict[str, str] = {}
    
    def add_section(self, section: DocumentSection) -> None:
        self.sections.append(section)
    
    def add_metadata(self, key: str, value: str) -> None:
        self.metadata[key] = value
    
    def generate_markdown(self) -> str:
        header = f"# {self.title}\n\n**Author:** {self.author}\n\n"
        if self.metadata:
            header += "**Metadata:**\n"
            for key, value in self.metadata.items():
                header += f"- {key}: {value}\n"
            header += "\n"
        
        body = "\n\n".join(str(section) for section in self.sections)
        return header + body
    
    def get_total_word_count(self) -> int:
        return sum(section.word_count for section in self.sections)

# Create a document generator
generator = DocumentGenerator("Python Document Engineering", "Prosegrammer Team")
generator.add_metadata("version", "1.0")
generator.add_metadata("language", "English")

# Add sections
intro_section = DocumentSection("Introduction", 
    "Document engineering combines programming with writing to create powerful tools for content creation and analysis.")
methods_section = DocumentSection("Methods", 
    "We use Python classes, inheritance, and composition to build flexible document processing systems.")
examples_section = DocumentSection("Examples", 
    "Here are practical examples of OOP patterns applied to document engineering challenges.")

generator.add_section(intro_section)
generator.add_section(methods_section)
generator.add_section(examples_section)

print("Total word count:", generator.get_total_word_count())
print("\nGenerated document preview:")
print(generator.generate_markdown()[:200] + "...")
```

::: {.fragment style="margin-top: -0.1em; font-size: 0.8em;"}

- {{< iconify fa6-solid lightbulb >}} **Composition benefits**: Flexible document assembly
- **Dynamic content**: Sections can be added or reordered easily
- **Clean architecture**: Each component has a clear purpose

:::

## OOP principles in document engineering

::: {.incremental style="margin-top: -0.15em; font-size: 0.95em;"}

- {{< iconify fa6-solid gear >}} **Abstraction**: Hide complexity of document processing
  - Document classes encapsulate file operations and metadata
  - Users work with high-level document objects, not low-level details

- {{< iconify fa6-solid gear >}} **Inheritance**: Create document type hierarchies
  - Base `Document` class with common functionality
  - Specialized subclasses like `TechnicalDocument`, `Report`, `Manual`
  - Shared behavior through inheritance chains

- {{< iconify fa6-solid gear >}} **Encapsulation**: Protect document state and behavior
  - Private attributes store sensitive document data
  - Public methods provide controlled access to document operations
  - Data integrity maintained through encapsulation

- {{< iconify fa6-solid gear >}} **Polymorphism**: Process different document types uniformly
  - Document processors work with any document type
  - Same interface handles different document formats
  - Extensible system for new document types and processors

:::

## Conclusion: OOP empowers prosegrammers

::: {.fragment style="margin-top: 0.1em; font-size: 0.9em;"}

- **Object-oriented programming transforms document engineering**:
  - Classes model real-world document entities and relationships
  - Inheritance creates flexible document type hierarchies
  - Polymorphism enables unified processing of diverse content
  - Encapsulation ensures data integrity and clean interfaces

- **Practical applications for prosegrammers**:
  - Build automated document generation systems
  - Create extensible text analysis frameworks
  - Develop collaborative document management tools
  - Design scalable content processing pipelines

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.1em; font-size: 0.85em;"}

{{< iconify fa6-solid rocket >}} **OOP + Document Engineering = Powerful Tools for Prosegrammers!**
*Master these concepts to build the next generation of document processing systems!*

:::

