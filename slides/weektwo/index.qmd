---
title: "Exploring the Python Programming Language"
description: "What are some of the key features of Python?"
date: "2025-09-01"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Prosegrammers"
---

# What are some key features of the Python programming language?

::: incremental

- Simple and readable syntax
- Defining and evaluating expressions
- Declaring and using variables with types
- Creating and using collections

:::

## Python for document engineering

::: {.incremental .fade-right style="margin-top: -0.2em; font-size: 0.775em;"}

- {{< iconify fa6-solid gear >}} **Simple and readable syntax**
  - Easy to learn and understand
  - Code looks similar to written English
  - Focus on solving problems, not complex syntax

- {{< iconify fa6-solid code >}} **Excellent text processing capabilities**
  - Built-in string operations and methods
  - Rich collection types for organizing data
  - Powerful libraries for document manipulation

- {{< iconify fa6-solid book-open >}} **Perfect suite of tools for prosegrammers**
  - Combines programming power with clear, readable code
  - Ideal for creating tools that work with documents

:::

# Thinking and writing about Python programs

::: incremental

- **Sequence**: Run operations one after another in an order
- **Selection**: Decide which operations will execute
- **Iteration**: Repeat an operation a specific number of times

:::

::: {.fragment .fade .boxed-content style="font-size: 1.0em;"}

{{< iconify fa6-solid microscope >}} These three concepts form the foundation of
all programming logic! **Let's explore these in greater detail!**

:::

## Sequence: Run operations one-by-one

```{python}
def create_greeting(name: str) -> str:
    """Create a personalized greeting message for documents."""
    greeting = "Hello, " + name + "!"
    message = greeting + " Welcome to Document Engineering."
    return message

# call the function with different names
result = create_greeting("Alice")
print(result)
```

::: {.incremental .fade style="margin-top: -0.25em; font-size: 0.8em;"}

- Calling the `create_greeting` function causes each line to run sequentially
- First: concatenate name with "Hello, " and "!"
- Second: add the welcome message to create full greeting
- Third: return the complete message to caller
- **Document connection**: generating personalized content for reports!

:::

## Selection: Use conditional logic

```{python}
def format_document_title(title: str, capitalized: bool) -> str:
    """Format a document title based on style preference."""
    if capitalized:
        formatted_title = title.upper()
        result = "DOCUMENT: " + formatted_title
    else:
        formatted_title = title.title()
        result = "Document: " + formatted_title
    return result

# test both formatting styles
print(format_document_title("user guide", True) + " / "
      + format_document_title("user guide", False))
```

::: {.incremental .fade style="margin-top: -0.25em; font-size: 0.8em;"}

- The `if` statement checks the value of the `formal` parameter
- Different code executes based on whether `formal` is `True` or `False`
- **Document connection**: adapting content style for different audiences!

:::

## Iteration: Repeat an operation

```{python}
def count_words_in_documents(documents: list) -> dict:
    """Count total words across multiple documents."""
    word_counts = {}
    for doc_name in documents:
        word_count = len(doc_name.split())  # simple word count
        word_counts[doc_name] = word_count
    return word_counts

# test with sample document names
docs = ["Manual", "Installation Guide", "API Reference Document"]
counts = count_words_in_documents(docs)
print(counts)
```

::: {.incremental .fade style="margin-top: -0.25em; font-size: 0.8em;"}

- `word_counts` is a dictionary that starts out empty
- The `for` loop iterates through each document name in the list
- **Document connection**: analyzing multiple documents in a collection!

:::

# Collections contain multiple values

::: {.fragment .fade-right}
- {{< iconify fa6-solid lightbulb >}} **Strings**: `str` in Python
- {{< iconify fa6-solid lightbulb >}} **Lists**: `list` in Python
- {{< iconify fa6-solid lightbulb >}} **Tuples**: `tuple` in Python
- {{< iconify fa6-solid lightbulb >}} **Dictionaries**: `dict` in Python
- {{< iconify fa6-solid lightbulb >}} **Sets**: `set` in Python
:::

::: {.fragment .fade-up style="margin-top: -0.5em;"}
Let's explore each of these in greater detail!
:::

## Creating and using a string

```{pyodide}
#| autorun: true
#| max-lines: 5
# strings store text data - perfect for documents!
title = "Document Engineering: "
subtitle = "A Beginner's Guide"
full_title = title + subtitle
print("Title type:", type(full_title))
print("Full title:", full_title)
print("Character at position 9:", full_title[9])
page_number = str(42)
print("Page as string:", page_number[0])
```

::: {.incremental style="margin-top: -0.25em; font-size: 0.85em;"}

- What is the purpose of the `type` function?
- What is the purpose of the `full_title[9]` notation?
- What is the purpose of the `str` function?
- What is the purpose of the `+` operator?
- **Document connection**: combining text for titles and content!

:::

## Creating and using a list

```{pyodide}
#| autorun: true
#| max-lines: 12
# lists store multiple items - great for document sections!
chapters = ["Introduction", "Basics", "Advanced", "Conclusion"]
print("List type:", type(chapters))
chapters.append("Appendix")
print("First chapter:", chapters[0])
print("Second chapter:", chapters[1])
print("Last chapter:", chapters[-1])
print("Second to last:", chapters[-2])
chapters[2] = "Intermediate"
chapters[3] = "Expert Topics"
print("Updated chapters:", chapters)
```

::: {.fragment .fade-up style="margin-top: -0.05em; font-size: 0.9em;"}

What does this illustrate about the `list` type in Python?

:::

## Creating and using a tuple

```{pyodide}
#| autorun: true
#| max-lines: 4
# tuples store immutable data - perfect for document metadata!
doc_info = ("User Manual", "v2.1", "2025-09-01", "PDF", "42 pages")
print("Tuple type:", type(doc_info))
print("Document info:", doc_info)
print("Document format:", doc_info[3])
print("Page count:", doc_info[4])
```

::: {.fragment .fade-up style="margin-top: -0.1em; font-size: 0.87em;"}

- What are some invalid operations on a `tuple`?
  - `doc_info[3] = "DOCX"`
  - `doc_info.append("English")`
  - `doc_info.remove("PDF")`
  - `doc_info.insert("HTML")`
  - `doc_info.pop()`
- **Document connection**: storing fixed document properties!

:::

## Creating and using a dictionary

```{pyodide}
#| autorun: true
#| max-lines: 10
# dictionaries store key-value pairs - ideal for document properties!
document = dict()
document["title"] = "Python Programming Guide"
document["author"] = "Jane Smith"
document["pages"] = 156
document["language"] = "English"
print("Dictionary type:", type(document))
print("Document details:", document)
print("Document title:", document["title"])
print("Page count:", document["pages"])
```

::: {.incremental .fade-up style="margin-top: -0.1em; font-size: 0.825em;"}

- The `dict` function creates an empty dictionary called `document`
- Dictionaries store key-value pairs like `{"title": "Python Programming Guide"}`
- The keys can be strings, numbers, or other hashable types
- The values can be of any data type like `str`, `int`, and `float`
- It is possible to lookup a value by its key as in `document["title"]`
- **Document connection**: storing structured document information!

:::

## Creating and using a set

```{pyodide}
#| autorun: true
#| max-lines: 10
# sets store unique items - useful for tracking document keywords!
keywords = {"python", "programming"}
print("Set type:", type(keywords))
keywords.add("documentation")
keywords.add("python")  # duplicate - won't be added again
keywords.add("python")  # another duplicate
keywords.add("tutorial")
print("Unique keywords:", keywords)
print("Keyword count:", len(keywords))
```

::: {.incremental .fade-up style="margin-top: -0.1em; font-size: 0.87em;"}

- Sets do not store duplicate values
- The data in a set must be hashable
- The `add` function places more data in a set
- Repeated calls of `add` with `"python"` do not change the set
- Be careful, `{}` is an empty dictionary, not a set!
- **Document connection**: maintaining unique tags and keywords!

:::

# Operations to perform on most collections

::: {.fragment .fade-right}
- {{< iconify fa6-solid lightbulb >}} Determine the *length* of a collection
- {{< iconify fa6-solid lightbulb >}} *Add* an element to or *remove* element from a collection
- {{< iconify fa6-solid lightbulb >}} *Access* an element in a collection
- {{< iconify fa6-solid lightbulb >}} Determine if a collection *contains* an element
- {{< iconify fa6-solid lightbulb >}} *Iterate* through all of the elements in a collection
- {{< iconify fa6-solid lightbulb >}} *Slice* a collection to get a subset of its elements
:::

## Sizing and slicing collections

```{pyodide}
#| autorun: true
#| max-lines: 8
# working with document content and metadata
title = "Document Engineering Guide"
sections = ["Introduction", "Methods", "Examples", "Conclusion"]
metadata = ("Guide", "Engineering")
properties = {"type": "manual", "version": 2, "active": True}
tags = {"python", "docs", "engineering", "tutorial", "python", "docs"}
print("Lengths:", len(title), len(sections), len(metadata), len(properties), len(tags))
```

<p class="codespacer">

```{pyodide}
#| autorun: true
#| max-lines: 8
# slicing collections to extract parts
title = "Document Engineering Guide"
sections = ["Introduction", "Methods", "Examples", "Conclusion"]
metadata = ("Guide", "Engineering", "Tutorial", "2025")
print("Title slice:", title[9:20])  # "Engineering"
print("First word:", title[0:8])    # "Document"
print("Last sections:", sections[2:])  # ["Examples", "Conclusion"]
print("First two metadata:", metadata[:2])  # ("Guide", "Engineering")
```

## Iterating through lists and tuples

```{pyodide}
#| autorun: true
#| max-lines: 12
# processing document sections and metadata
chapters = ["Intro", "Setup", "Examples"]
doc_metadata = ("Technical Guide", "v1.0", "2025", "English")

print("Chapters:")
for chapter in chapters:
    print("  " + chapter)

print()
print("Metadata:")
for item in doc_metadata:
    print("  " + str(item))
```

## Iterating through sets and strings

```{pyodide}
#| autorun: true
#| max-lines: 12
# working with document keywords and text
document_tags = {"python", "tutorial", "beginners"}
filename = "guide.pdf"

print("Document Tags:")
for tag in document_tags:
    print("  " + tag)

print()
print("Filename Characters:")
for character in filename:
    print("  " + character)
```

## Iterating through a dictionary

```{pyodide}
#| autorun: true
#| max-lines: 14
# processing document properties
document_info = {"title": "Python Guide", "pages": 150, "language": "English"}

print("Method 1 - Keys only:")
for key in document_info:
    print(key, "->", document_info[key])

print()
print("Method 2 - Items (key-value pairs):")
for key, value in document_info.items():
    print(key, "->", value)

print()
print("Method 3 - Explicit keys:")
for key in document_info.keys():
    print(key, "->", document_info[key])
```

## Mutable and Immutable Collections

::: {.fragment .fade-right}

- **Mutable Collections**: *can be changed after creation*
  - Lists (`list`) - great for document sections that may change
  - Dictionaries (`dict`) - perfect for document properties
  - Sets (`set`) - ideal for collections of unique keywords

:::

::: {.fragment .fade-right style="margin-top: -0.75em;"}

- **Immutable Collections**: *cannot be changed after creation*
  - Tuples (`tuple`) - excellent for fixed document metadata
  - Strings (`str`) - text content that won't be modified

:::

::: {.fragment .fade-right style="margin-top: -0.5em; font-size: 0.9em;"}

- {{< iconify fa6-solid lightbulb >}} Understanding mutability helps prosegrammers choose the right collection type for document data!

:::

## Containment checking for collections

```{pyodide}
#| autorun: true
#| max-lines: 12
# checking if content exists in document data
title = "Python Programming"
chapters = ["Introduction", "Basics", "Advanced", "Conclusion"]
metadata = ("Guide", "v2.0")
document_info = {"author": "Jane Smith", "pages": 200, "language": "English"}
keywords = {"python", "programming", "tutorial", "beginner"}

print("'Programming' in title:", "Programming" in title)
print("'Tutorial' in title:", "Tutorial" in title)
print("'Basics' in chapters:", "Basics" in chapters)
print("'Guide' in metadata:", "Guide" in metadata)
print("'author' in document_info:", "author" in document_info)
print("'python' in keywords:", "python" in keywords)
```

## More containment checking

```{pyodide}
#| autorun: true
#| max-lines: 12
# testing for missing content in document data
title = "Python Programming"
chapters = ["Introduction", "Basics", "Advanced", "Conclusion"]
metadata = ("Guide", "v2.0")
document_info = {"author": "Jane Smith", "pages": 200, "language": "English"}
keywords = {"python", "programming", "tutorial", "beginner"}

print("'Java' in title:", "Java" in title)
print("'Appendix' in chapters:", "Appendix" in chapters)
print("'v3.0' in metadata:", "v3.0" in metadata)
print("'publisher' in document_info:", "publisher" in document_info)
print("'advanced' in keywords:", "advanced" in keywords)
print("'Python' in keywords:", "Python" in keywords)  # case matters!
```

## Working with document content

```{python}
def find_document_in_library(library: list, document_name: str) -> bool:
    """Check if a document exists in our document library."""
    # assume the document is not in the library
    found = False
    # check if the document name is in the library
    if document_name in library:
        found = True
    # return boolean to indicate whether document was found
    return found

# test with sample document library
my_library = ["Python Guide", "Web Development", "Data Analysis"]
result = find_document_in_library(my_library, "Python Guide")
print("Found 'Python Guide':", result)
```

::: {.incremental .fade-right}

- What is the type of the parameter called `library`?
- What is the type of the parameter called `document_name`?
- What is the return type of `find_document_in_library`?
- How does Python implement `if document_name in library`?

:::

## Working with document metadata

```{python}
def check_document_property(metadata: tuple, property_name: str) -> bool:
    """Check if a specific property exists in document metadata."""
    # assume the property is not in the metadata
    found = False
    # check if the property name is in the metadata tuple
    if property_name in metadata:
        found = True
    # return boolean to indicate whether property was found
    return found

# test with sample document metadata
doc_metadata = ("User Manual", "v2.1", "English", "PDF")
result = check_document_property(doc_metadata, "PDF")
print("Contains 'PDF' format:", result)
```

::: {.incremental .fade-right}

- What is the type of the parameter called `metadata`?
- What is the type of the parameter called `property_name`?
- What is the return type of `check_document_property`?
- How does Python implement `if property_name in metadata`?

:::


## Key features of Python for beginners

::: fragment

### Defining and evaluating expressions

```{pyodide}
#| autorun: true
#| max-lines: 6
# Python makes calculations easy and readable
pages_per_chapter = 15
total_chapters = 8
total_pages = pages_per_chapter * total_chapters
print("Total pages in document:", total_pages)
```

:::

::: fragment

### Declaring and using variables with types

```{pyodide}
#| autorun: true
#| max-lines: 6
# Variables store different types of document information
document_title = "Python for Beginners"
page_count = 156
is_published = True
print("Title:", document_title, "| Pages:", page_count, "| Published:", is_published)
```

:::

::: fragment

### Creating and using collections

```{pyodide}
#| autorun: true
#| max-lines: 6
# Collections organize multiple pieces of information
chapter_titles = ["Introduction", "Variables", "Functions", "Collections"]
print("Chapter list:", chapter_titles)
print("First chapter:", chapter_titles[0])
```

:::

## Building your Python foundation

::: {.fragment style="margin-top: 0.1em; font-size: 0.9em;"}

- **Master the fundamentals**: sequence, selection, iteration
- **Understand collections**: strings, lists, tuples, dictionaries, sets
- **Practice with document examples**: titles, chapters, metadata, keywords
- **Connect Python to document engineering**: 
  - Process text and analyze content
  - Organize document information systematically
  - Automate repetitive document tasks

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.1em; font-size: 0.85em;"}

{{< iconify fa6-solid rocket >}} You're ready to become a prosegrammer! Python + documents = powerful automation and analysis capabilities!

:::

